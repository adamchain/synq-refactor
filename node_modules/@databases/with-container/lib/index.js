"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.killOldContainers = exports.waitForDatabaseToStart = exports.startDockerContainer = exports.pullDockerImage = exports.imageExists = exports.detectPort = void 0;
const net_1 = require("net");
const spawn = require("cross-spawn");
const modern_spawn_1 = require("modern-spawn");
exports.detectPort = require('detect-port');
async function imageExists(options) {
    const stdout = await (0, modern_spawn_1.spawnBuffered)('docker', ['images', '--format', '{{json .}}'], {
        debug: options.debug,
    }).getResult('utf8');
    const existingImages = stdout
        .trim()
        .split('\n')
        .map((str) => {
        try {
            return JSON.parse(str);
        }
        catch (ex) {
            console.warn('Unable to parse: ' + str);
            return null;
        }
    })
        .filter((n) => n != null);
    const [Repository, Tag] = options.image.split(':');
    return existingImages.some((i) => i.Repository === Repository && (!Tag || i.Tag === Tag));
}
exports.imageExists = imageExists;
async function pullDockerImage(options) {
    if (!options.refreshImage &&
        /.+\:.+/.test(options.image) &&
        (await imageExists(options))) {
        console.warn(options.image +
            ' already pulled (use mysql-test start --refresh or ops.refreshImage to refresh)');
        return;
    }
    console.warn('Pulling Docker Image ' + options.image);
    await (0, modern_spawn_1.spawnBuffered)('docker', ['pull', options.image], {
        debug: options.debug,
    }).getResult();
}
exports.pullDockerImage = pullDockerImage;
function startDockerContainer(options) {
    const env = options.environment || {};
    const envArgs = [];
    Object.keys(env).forEach((key) => {
        envArgs.push('--env');
        envArgs.push(`${key}=${env[key]}`);
    });
    return spawn('docker', [
        'run',
        '--platform',
        'linux/amd64',
        '--name',
        options.containerName,
        '-t',
        '--rm',
        '-p',
        `${options.externalPort}:${options.internalPort}`,
        ...(options.detached ? ['--detach'] : []),
        // set enviornment variables
        ...envArgs,
        options.image,
    ], {
        stdio: options.debug ? 'inherit' : 'ignore',
    });
}
exports.startDockerContainer = startDockerContainer;
async function waitForDatabaseToStart(options) {
    await new Promise((resolve, reject) => {
        let finished = false;
        const timeout = setTimeout(() => {
            finished = true;
            reject(new Error(`Unable to connect to database after ${options.connectTimeoutSeconds} seconds.${options.enableDebugInstructions
                ? ` ${options.enableDebugInstructions}`
                : ``}`));
        }, options.connectTimeoutSeconds * 1000);
        function test() {
            console.warn(`Waiting for ${options.containerName} on port ${options.externalPort}...`);
            (options.testConnection
                ? options.testConnection({
                    ...options,
                    testPortConnection: async () => await testConnection(options),
                })
                : testConnection(options)).then((isConnected) => {
                if (finished)
                    return;
                if (isConnected) {
                    finished = true;
                    clearTimeout(timeout);
                    setTimeout(resolve, 1000);
                }
                else {
                    setTimeout(test, 500);
                }
            }, (err) => {
                reject(err);
            });
        }
        test();
    });
}
exports.waitForDatabaseToStart = waitForDatabaseToStart;
async function testConnection(options) {
    return new Promise((resolve) => {
        const connection = (0, net_1.connect)(options.externalPort)
            .on('error', () => {
            resolve(false);
        })
            .on('connect', () => {
            connection.end();
            resolve(true);
        });
    });
}
async function killOldContainers(options) {
    await (0, modern_spawn_1.spawnBuffered)('docker', ['kill', options.containerName], {
        debug: options.debug,
    }); // do not check exit code as there may not be a container to kill
    await (0, modern_spawn_1.spawnBuffered)('docker', ['rm', options.containerName], {
        debug: options.debug,
    }); // do not check exit code as there may not be a container to remove
}
exports.killOldContainers = killOldContainers;
async function startContainer(options) {
    if (isNaN(options.connectTimeoutSeconds)) {
        throw new Error('connectTimeoutSeconds must be a valid integer.');
    }
    await Promise.all([pullDockerImage(options), killOldContainers(options)]);
    const { defaultExternalPort, ...rawOptions } = options;
    const externalPort = rawOptions.externalPort || (await (0, exports.detectPort)(defaultExternalPort));
    if (typeof externalPort !== 'number') {
        throw new Error('Expected external port to be a number');
    }
    const opts = {
        detached: false,
        ...rawOptions,
        externalPort,
    };
    console.warn('Starting Docker Container ' + opts.containerName);
    const proc = startDockerContainer(opts);
    await waitForDatabaseToStart(opts);
    return {
        proc,
        externalPort,
        async kill() {
            await killOldContainers(options);
        },
    };
}
exports.default = startContainer;
//# sourceMappingURL=index.js.map