import AppliedMigration from './types/AppliedMigration';
import MigrationFile from './types/MigrationFile';
import Operation from './types/Operation';
import { SequenceErrorIgnoreCode } from './methods/validateMigrationsSequence';
export declare function sortMigrations<T extends {
    readonly index: number;
    readonly applied_at?: Date;
}>(migrations: readonly T[]): T[];
export interface MigrationCommandParameters {
    applied_migration?: number;
    migration_file?: number;
    error_type?: SequenceErrorIgnoreCode;
    ignored_errors?: SequenceErrorIgnoreCode[];
}
export default class MigrationsContext {
    readonly originalAppliedMigrations: readonly AppliedMigration[];
    private readonly _appliedMigrations;
    private readonly _migrationFiles;
    private readonly _operations;
    readonly parameters: MigrationCommandParameters;
    constructor(appliedMigrations: readonly AppliedMigration[], migrationFiles: readonly MigrationFile[], parameters: MigrationCommandParameters);
    get appliedMigrations(): readonly AppliedMigration[];
    get migrationFiles(): readonly MigrationFile[];
    get operations(): readonly Operation[];
    migrationIdToString(id: number): string;
    fixMigrationName(migration: MigrationFile): MigrationFile;
    hasAppliedMigration(migration: MigrationFile): boolean;
    getAppliedMigration(migration: MigrationFile): AppliedMigration | undefined;
    getMigrationFile(index: number): MigrationFile | undefined;
    markMigrationAsApplied(migration: MigrationFile): void;
    markAppliedMigrationAsObsolete(migration: AppliedMigration): void;
    ignoreErrorPermanently(migration: AppliedMigration, error: string): void;
    ignoreErrorTemporarily(migration: AppliedMigration, error: string): AppliedMigration;
    writeMigrationFile(migration: MigrationFile): void;
    changeMigrationFileIndex(migration: MigrationFile, newIndex: number): void;
    deleteMigrationFile(migration: MigrationFile): void;
    applyMigration(migration: MigrationFile): void;
}
