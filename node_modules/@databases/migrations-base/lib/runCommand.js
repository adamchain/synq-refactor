"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

const semver = require("semver");

const Result_1 = require("./types/Result");

const readMigrationsDir_1 = require("./methods/readMigrationsDir");

const MigrationContext_1 = require("./MigrationContext");

const applyOperations_1 = require("./methods/applyOperations");

async function runCommand(engine, command, parameters, {
  dryRun = false,
  handleError = async e => Result_1.default.fail(e),
  beforeOperation = async () => undefined,
  afterOperation = async () => undefined
} = {}) {
  const databaseVersionResult = await engine.checkDatabaseVersion();
  if (!databaseVersionResult.ok) return databaseVersionResult;
  const schemaVersionResult = await engine.tx(async tx => {
    const currentSchemaVersion = await tx.getVersion();

    if (semver.gt(currentSchemaVersion, engine.packageVersion)) {
      return Result_1.default.fail({
        code: 'database_uses_newer_version',
        databaseVersion: currentSchemaVersion,
        packageVersion: engine.packageVersion
      });
    }

    if (semver.lt(currentSchemaVersion, engine.packageVersion)) {
      if (dryRun) {
        return Result_1.default.fail({
          code: 'database_uses_older_version',
          databaseVersion: currentSchemaVersion,
          packageVersion: engine.packageVersion
        });
      } // "updateVersion" should run any necessary migrations


      await tx.updateVersion(currentSchemaVersion, engine.packageVersion, v => semver.lt(currentSchemaVersion, v));
    }

    return Result_1.default.ok();
  });
  if (!schemaVersionResult.ok) return schemaVersionResult;
  const migrationFilesResult = await readMigrationsDir_1.default(engine.directory);
  if (!migrationFilesResult.ok) return migrationFilesResult;
  const appliedMigrations = await engine.tx(async tx => await tx.getMigrations());
  const ctx = new MigrationContext_1.default(appliedMigrations, migrationFilesResult.value, parameters);
  let commandResult = command(ctx);

  while (!commandResult.ok) {
    const handled = await handleError(commandResult.reason, ctx);
    if (!handled.ok) return handled;
    commandResult = command(ctx);
  }

  if (dryRun) {
    for (const operation of ctx.operations) {
      if (await beforeOperation(operation)) {
        return Result_1.default.ok();
      }

      await afterOperation(operation);
    }
  } else {
    await applyOperations_1.default(ctx, engine, {
      beforeOperation,
      afterOperation
    });
  }

  return Result_1.default.ok();
}

exports.default = runCommand;