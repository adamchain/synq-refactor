"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function sortMigrations(migrations) {
  return migrations.slice().sort((a, b) => a.index - b.index || (a.applied_at && b.applied_at ? a.applied_at.getTime() - b.applied_at.getTime() : 0));
}

exports.sortMigrations = sortMigrations;

function insertMigration(migrations, newMigration) {
  const indexOfMigrationAfterTheNewOne = migrations.findIndex(m => m.index > newMigration.index);

  if (indexOfMigrationAfterTheNewOne === -1) {
    migrations.push(newMigration);
  } else {
    migrations.splice(indexOfMigrationAfterTheNewOne, 0, newMigration);
  }
}

class MigrationsContext {
  constructor(appliedMigrations, migrationFiles, parameters) {
    this._operations = [];
    this.parameters = {};
    this.originalAppliedMigrations = sortMigrations(appliedMigrations);
    this._appliedMigrations = sortMigrations(appliedMigrations);
    this._migrationFiles = sortMigrations(migrationFiles);
    this.parameters = parameters;
  }

  get appliedMigrations() {
    return this._appliedMigrations.filter(m => !m.obsolete);
  }

  get migrationFiles() {
    return this._migrationFiles;
  }

  get operations() {
    return this._operations;
  }

  migrationIdToString(id) {
    const length = this.migrationFiles.length ? Math.max(...this.migrationFiles.map(f => f.name.split('-').length)) : 3;
    return `${id}`.padStart(length, '0');
  }

  fixMigrationName(migration) {
    const name = migration.name.split('-').slice(1).join('-');
    return { ...migration,
      name: `${this.migrationIdToString(migration.index)}-${name}`
    };
  }

  hasAppliedMigration(migration) {
    return this.appliedMigrations.some(m => m.index === migration.index);
  }

  getAppliedMigration(migration) {
    return this.appliedMigrations.find(m => m.index === migration.index);
  }

  getMigrationFile(index) {
    return this.migrationFiles.find(m => m.index === index);
  }

  markMigrationAsApplied(migration) {
    if (this.hasAppliedMigration(migration)) {
      throw new Error(`Migration "${migration.name}" is already applied`);
    }

    const applied = {
      index: migration.index,
      name: migration.name,
      script: migration.script,
      applied_at: new Date(),
      ignored_error: null,
      obsolete: false
    };
    insertMigration(this._appliedMigrations, applied);

    this._operations.push({
      kind: 'applied',
      value: applied
    });
  }

  markAppliedMigrationAsObsolete(migration) {
    const index = this._appliedMigrations.findIndex(m => m.index === migration.index && !m.obsolete);

    if (index === -1) {
      throw new Error(`AppliedMigration "${migration.name}" does not exist`);
    }

    const applied = { ...this._appliedMigrations[index],
      obsolete: true
    };
    this._appliedMigrations[index] = applied;

    this._operations.push({
      kind: 'obsolete',
      value: applied
    });
  }

  ignoreErrorPermanently(migration, error) {
    const applied = this.ignoreErrorTemporarily(migration, error);

    this._operations.push({
      kind: 'ignore_error',
      value: applied
    });
  }

  ignoreErrorTemporarily(migration, error) {
    const index = this._appliedMigrations.findIndex(m => m.index === migration.index && !m.obsolete);

    if (index === -1) {
      throw new Error(`AppliedMigration "${migration.name}" does not exist`);
    }

    const applied = { ...this._appliedMigrations[index],
      ignored_error: error
    };
    this._appliedMigrations[index] = applied;

    this._operations.push({
      kind: 'obsolete',
      value: applied
    });

    return applied;
  }

  writeMigrationFile(migration) {
    if (this.getMigrationFile(migration.index)) {
      throw new Error(`MigrationFile ${migration.index} already exists`);
    }

    insertMigration(this._migrationFiles, migration);

    this._operations.push({
      kind: 'write',
      value: migration
    });
  }

  changeMigrationFileIndex(migration, newIndex) {
    const fileToChange = this.getMigrationFile(migration.index);

    if (!fileToChange || fileToChange.name !== migration.name) {
      throw new Error(`MigrationFile ${migration.name} does not exist`);
    }

    const fileThatWouldBeReplaced = this.getMigrationFile(newIndex);

    if (fileThatWouldBeReplaced) {
      throw new Error(`There is already a MigrationFile with index ${newIndex} called ${fileThatWouldBeReplaced.name}.`);
    }

    this._migrationFiles.splice(this._migrationFiles.findIndex(m => m.index === migration.index), 1);

    const newMigration = this.fixMigrationName({ ...migration,
      index: newIndex
    });
    insertMigration(this._migrationFiles, newMigration);

    this._operations.push({
      kind: 'rename',
      value: {
        from: migration,
        to: newMigration
      }
    });
  }

  deleteMigrationFile(migration) {
    if (!this.getMigrationFile(migration.index)) {
      throw new Error(`MigrationFile ${migration.name} does not exist`);
    }

    this._migrationFiles.splice(this._migrationFiles.findIndex(m => m.index === migration.index), 1);

    this._operations.push({
      kind: 'delete',
      value: migration
    });
  }

  applyMigration(migration) {
    if (this.hasAppliedMigration(migration)) {
      throw new Error(`${migration.name} is already applied`);
    }

    this._operations.push({
      kind: 'apply',
      value: migration
    });
  }

}

exports.default = MigrationsContext;