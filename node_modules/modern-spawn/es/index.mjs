import CrossSpawn from 'cross-spawn';
import { exec, execSync, } from 'child_process';
async function getBuffer(stream, debug) {
    if (!stream)
        return Buffer.alloc(0);
    return await new Promise((resolve, reject) => {
        const buffers = [];
        stream.on('error', reject);
        stream.on('data', (data) => {
            if (debug)
                process[debug].write(data);
            buffers.push(data);
        });
        stream.on('end', () => resolve(Buffer.concat(buffers)));
    });
}
async function getStatusCode(cp) {
    return await new Promise((resolve, reject) => {
        cp.on('error', reject);
        cp.on('exit', (v) => resolve(v));
    });
}
export function formatCommand(command, args) {
    if (!args || !args.length) {
        return command;
    }
    return [command, ...args]
        .map((arg) => / /.test(arg) ? (/\"/.test(arg) ? `'${arg}'` : `"${arg}"`) : arg)
        .join(' ');
}
class ResultClass {
    constructor(command, args, stdout, stderr, status) {
        this.command = command;
        this.args = args;
        this.stdout = stdout;
        this.stderr = stderr;
        this.status = status;
    }
    getResult(encoding) {
        if (this.status !== 0) {
            const err = new Error(`${formatCommand(this.command, this.args)} exited with code ${this.status}:\n${this.stderr.toString('utf8')}`);
            err.code = 'NON_ZERO_EXIT_CODE';
            err.status = this.status;
            err.stdout = this.stdout;
            err.stderr = this.stderr;
            err.command = this.command;
            err.args = this.args;
            throw err;
        }
        if (encoding) {
            return this.stdout.toString(encoding);
        }
        return this.stdout;
    }
}
function toResultPromise(p) {
    async function getResult(str) {
        return p.then((r) => r.getResult(str));
    }
    return Object.assign(p, { getResult });
}
export function spawnBuffered(command, args, { debug, ...options } = {}) {
    const childProcess = CrossSpawn.spawn(command, args, options);
    return toResultPromise(Promise.all([
        getBuffer(childProcess.stdout, debug === true || (debug && debug.stdout) ? 'stdout' : undefined),
        getBuffer(childProcess.stderr, debug === true || (debug && debug.stderr) ? 'stderr' : undefined),
        getStatusCode(childProcess),
    ]).then(([stdout, stderr, status]) => {
        return new ResultClass(command, args, stdout, stderr, status);
    }));
}
export function spawnBufferedSync(command, args, { debug, ...options } = {}) {
    const result = CrossSpawn.sync(command, args, options);
    if (debug) {
        if (debug === true || debug.stdout) {
            process.stdout.write(result.stdout);
        }
        if (debug === true || debug.stderr) {
            process.stderr.write(result.stderr);
        }
    }
    if (result.error)
        throw result.error;
    return new ResultClass(command, args, result.stdout, result.stderr, result.status);
}
export function execBuffered(command, { debug, windowsHide, ...options } = {}) {
    return toResultPromise(new Promise((resolve) => {
        exec(command, { ...options, windowsHide: windowsHide !== false, encoding: 'buffer' }, (err, stdout, stderr) => {
            resolve([err, stdout, stderr]);
        });
    }).then(([err, stdout, stderr]) => {
        if (err && typeof err.code !== 'number') {
            throw err;
        }
        if (debug) {
            if (debug === true || debug.stdout) {
                process.stdout.write(stdout);
            }
            if (debug === true || debug.stderr) {
                process.stderr.write(stderr);
            }
        }
        return new ResultClass(command, undefined, stdout, stderr, (err && err.code) || 0);
    }));
}
export function execBufferedSync(command, { debug, windowsHide, ...options } = {}) {
    try {
        const stdout = execSync(command, {
            ...options,
            windowsHide: windowsHide !== false,
            ...(debug && (debug === true || debug.stdout) ? {} : { stdio: 'pipe' }),
        });
        if (debug) {
            if (debug === true || debug.stdout) {
                process.stdout.write(stdout);
            }
        }
        // TODO: get actual stderr rather than allocating an empty array
        return new ResultClass(command, undefined, stdout, Buffer.alloc(0), 0);
    }
    catch (ex) {
        if (ex.status && ex.stdout && ex.stderr) {
            if (debug) {
                if (debug === true || debug.stdout) {
                    process.stdout.write(ex.stdout);
                }
                if (debug === true || debug.stderr) {
                    process.stderr.write(ex.stderr);
                }
            }
            return new ResultClass(command, undefined, ex.stdout, ex.stderr, ex.status);
        }
        throw ex;
    }
}
//# sourceMappingURL=index.js.map